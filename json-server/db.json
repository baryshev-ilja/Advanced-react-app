{
  "posts": [
    {
      "id": "1",
      "title": "json-server",
      "userId": "1"
    },
    {
      "id": "2",
      "title": "json-server",
      "userId": "2"
    }
  ],
  "articles": [
    {
      "id": "1",
      "title": "Как правильно использовать тег <form>?",
      "subtitle": "Без этого тега ни одна форма работать не будет!",
      "img": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/9nYV/GAprFnvg7",
      "views": 351,
      "userId": "1",
      "createdAt": "25.01.2024",
      "type": [
        "HTML"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Кратко",
          "paragraphs": [
            "Тег <form> добавляет на страницу форму, которую пользователь может заполнить. Например, ввести своё имя, фамилию или почту. Данные формы отправляются на сервер."
          ]
        },
        {
          "id": "4",
          "title": "Пример",
          "type": "CODE",
          "code": "<form action=\"\" method=\"get\">\n  <p>\n    <label for=\"name\">Введите имя:</label>\n    <input type=\"text\" name=\"name\" id=\"name\" required>\n  </p>\n  <p>\n    <label for=\"email\">Введите email:</label>\n    <input type=\"email\" name=\"email\" id=\"email\" required>\n  </p>\n  <button type=\"submit\">Отправить</button>\n</form>\n"
        },
        {
          "id": "5",
          "type": "TEXT",
          "title": "Как понять",
          "paragraphs": [
            "Сайты используют формы, чтобы получить какую-то информацию от пользователя. Это может быть форма заказа в онлайн-магазине или форма обратной связи. Пользователь заполняет поля или выбирает нужную опцию в списке, а после отправки формы эти данные можно обработать."
          ]
        },
        {
          "id": "6",
          "type": "TEXT",
          "title": "Как пишется",
          "paragraphs": [
            "Стилизовать <form> можно с помощью CSS.",
            "На странице можно сделать сколько угодно форм. Но одновременно пользователь сможет отправить только одну заполненную форму."
          ]
        },
        {
          "id": "7",
          "type": "TEXT",
          "title": "Атрибуты",
          "paragraphs": [
            "action — здесь указывается ссылка на скрипт, который обработает форму. Это может быть полная URL-ссылка, а может быть относительная, типа html/sendform. Если не указать атрибут action, то страница будет просто обновляться каждый раз, когда отправляется форма.",
            "method — может определять, каким способом будут отправлены на сервер данные, которые ввёл пользователь. Есть два варианта:",
            "get — ответы пользователя дописываются в URL в формате «параметр=значение», например «email=name@yandex.ru». Выглядит это так: site.com/form?name=Max&email=name@yandex.ru. То есть параметр — это то, что вы спрашиваете у пользователя, а значение — его ответ. Пары «параметр=значение» разделяются знаком &. Вариант method=\"get\" используется по умолчанию, но у него есть ограничение: URL не должен получиться длиннее, чем 3000 символов.",
            "post — данные из формы пакуются в тело формы и отправляются на сервер. В этом случае нет ограничений по объёму данных, поэтому этот способ подойдёт для заполнения базы данных или отправки файлов.",
            "Ещё у атрибута method может быть третье значение — dialog. Если <form> находится внутри <dialog>, то поля формы не очищаются, а сама форма не делает запроса на сервер. Вместо этого, закрывается диалоговое окно. В статье «Работа с формами» можно узнать, как отправить данные на сервер с помощью JavaScript.",
            "name — уникальное имя формы. Пользователь его не увидит, зато скрипты смогут найти нужную форму. Например, по этому имени, можно получить доступ к форме из коллекции document.forms.",
            "autocomplete — включает или выключает автозаполнение для формы. Браузер может подставить данные, которые пользователь сохранил ранее, например, пароль, номер банковской карты или адрес. Если у пользователя в настройках браузера отключена функция автозаполнения, то этот атрибут уже ни на что не повлияет. Атрибут autocomplete можно задать и для конкретных элементов. Есть два значения:",
            "on — значение по умолчанию. Включает автозаполнение для этой формы.\noff — выключает автозаполнение. Например, если форма собирает уникальные данные типа капчи («Введите слово с картинки»).",
            "novalidate — у этого атрибута нет значения. Если его добавить, браузер не будет проверять правильность заполнения формы. Например, верно ли введён адрес почты или URL для тегов <input type=\"email\"> и <input type=\"url\"> соответственно. Обычно браузер проверяет, не пропустили ли вы @ или домен. В том числе, проверяется и заполнение обязательных полей.",
            "enctype — определяет, какой вид кодирования будет применён к данным из формы. Этот атрибут обязательно надо ставить, если через форму отправляются файлы, в остальных случаях — не обязательно. Есть три варианта кодирования:",
            "application/x-www-form-urlencoded — это значение по умолчанию. Данные будут кодироваться так, что пробелы превратятся в знак +, а символы вроде кириллицы будут представлены в шестнадцатеричном значении. Например, так будет выглядеть имя Степан: %D0%A1%D1%82%D0%B5%D0%BF%D0%B0%D0%BD",
            "multipart/form-data — вариант, который надо указать, если через форму отправляются файлы. В этом случае данные не кодируются.",
            "text/plain — в этом случае пробелы меняются на +, а остальные символы передаются без изменений."
          ]
        },
        {
          "id": "8",
          "type": "TEXT",
          "title": "Подсказки",
          "paragraphs": [
            "Никогда не используйте method=\"get\", если хочется отправить конфиденциальные данные, потому что их можно будет легко прочитать в запросе, который отправляет форма, и даже в адресной строке браузера.",
            "Вариант method=\"get\" удобен тем, что полученный URL с ответами можно сохранить в закладки. Например, пользователь может заполнить форму и поделиться ссылкой с результатами с кем-нибудь ещё."
          ]
        },
        {
          "id": "4",
          "title": "Ещё примеры",
          "type": "CODE",
          "code": "<!-- Эта форма отправит значение методом GET — мы получим URL с ответом -->\n  <form action=\"\" method=\"get\">\n    <label>\n      Имя первого гостя:\n      <input type=\"text\" name=\"name\">\n    </label>\n    <button type=\"submit\">Сохранить</button>\n  </form>\n\n<!-- Эта форма отправит данные методом POST -->\n<form action=\"\" method=\"post\">\n  <label for=\"post-name\">\n    Имя второго гостя:\n    <input id=\"post-name\" type=\"text\" name=\"name\">\n  </label>\n  <button type=\"submit\">Сохранить</button>\n</form>\n\n<!-- Форма с радиокнопками -->\n<form action=\"\" method=\"post\">\n  <fieldset>\n    <legend>Выберите прожарку</legend>\n    <label>\n      <input type=\"radio\" name=\"level\">\n      Rare\n    </label>\n    <label>\n      <input type=\"radio\" name=\"level\"checked>\n      Medium\n    </label>\n    <label>\n      <input type=\"radio\" name=\"level\">\n      Well Done\n    </label>\n  </fieldset>\n</form>\n"
        }
      ]
    },
    {
      "id": "2",
      "title": "display, display, display...",
      "subtitle": "Объясняем, как менять стандартный тип отображения на произвольный",
      "img": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/66f9/EWKBTdnou",
      "views": 237,
      "userId": "1",
      "createdAt": "10.02.2024",
      "type": [
        "CSS"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Кратко",
          "paragraphs": [
            "По умолчанию почти все элементы в HTML имеют блочный и строчный тип отображения. Но в вёрстке часто бывает, что нам нужно сделать элемент не строчным, а блочным. И наоборот.",
            "Тут на помощь приходит свойство display",
            "Помимо значений block (блочное отображение) и inline (строчное отображение) существует смешанное значение inline-block (строчно-блочное отображение).",
            "Бывают и другие специфичные значения, например, flex, grid, table-cell."
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "Пример",
          "paragraphs": [
            "Частая ситуация: на странице нужно показать иконки соцсетей со ссылками на аккаунты."
          ]
        },
        {
          "id": "3",
          "type": "CODE",
          "code": "<div class=\"wrapper\">\n  <ul class=\"social\">\n    <li class=\"social__item twitter\">\n      <a href=\"\" class=\"social__link\"></a>\n    </li>\n    <li class=\"social__item fb\">\n      <a href=\"\" class=\"social__link\"></a>\n    </li>\n    <li class=\"social__item youtube\">\n      <a href=\"\" class=\"social__link\"></a>\n    </li>\n  </ul>\n</div>\n"
        },
        {
          "id": "4",
          "type": "TEXT",
          "paragraphs": [
            "Обратите внимание, что внутри ссылок ничего не написано. Нам не нужно выводить название соцсети, а нужно вывести иконку с логотипом. Что мы и сделаем при помощи фона.",
            "Выстраиваем пункты списка в ряд, а не друг под другом:"
          ]
        },
        {
          "id": "5",
          "type": "CODE",
          "code": ".social__item {\n  display: inline-block;\n}\n"
        },
        {
          "id": "6",
          "type": "TEXT",
          "paragraphs": [
            "Превращаем ссылки из строчных в блочные элементы. После этого можем задать высоту и ширину:"
          ]
        },
        {
          "id": "7",
          "type": "CODE",
          "code": ".social__link {\n  display: block;\n  width: 30px;\n  height: 30px;\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: contain;\n}\n"
        },
        {
          "id": "8",
          "type": "TEXT",
          "paragraphs": [
            "Задаём иконки фоном для каждой отдельной ссылки:"
          ]
        },
        {
          "id": "9",
          "type": "CODE",
          "code": ".twitter {\n  background-image: url(twitter-round-blue.png);\n}\n\n.fb {\n  background-image: url(fb-square-blue.png);\n}\n\n.youtube {\n  background-image: url(youtube-red-square.png);\n}\n"
        },
        {
          "id": "10",
          "type": "TEXT",
          "paragraphs": [
            "По умолчанию ссылки — строчные. Это значит, что им нельзя задать размеры (width и height) и фоновую картинку.",
            "Пишем display: block, и строка превращается в условный прямоугольник, у которого могут быть и размеры, и фон.",
            "После этого смело меняем размер на нужный нам и фоном выводим иконки каждой из соцсетей.",
            "Помимо этого по ходу решения задачи мы установили свойство display: inline-block для пунктов списка с классом social__item. За счёт этого элементы, которые по умолчанию блочные, приобретают внешние признаки строчных элементов. Вместо того чтобы выстраиваться друг под другом, пункты списка теперь стоят рядом, в строку."
          ]
        },
        {
          "id": "11",
          "type": "TEXT",
          "title": "Как понять",
          "paragraphs": [
            "Каждый HTML-элемент по умолчанию имеет свой тип отображения. Например, ссылки нужны для оборачивания слов и фраз. Значит, они должны быть строчными, чтобы не разорвать окружающий текст.",
            "Но по разным причинам может понадобиться изменить стандартное отображение на то, которое больше подходит под решение текущей задачи."
          ]
        },
        {
          "id": "12",
          "type": "TEXT",
          "title": "Как пишется",
          "paragraphs": [
            "Пишем имя свойства display и после двоеточия через пробел указываем одно из доступных значений при помощи ключевого слова.",
            "Значения свойства, которые встречаются в работе чаще всего:",
            "none — полностью скрывает элемент со страницы, не удаляя его при этом из HTML-разметки.",
            "block — элемент ведёт себя как блочный.",
            "inline-block — элемент ведёт себя снаружи как строчный, а внутри как блочный.",
            "flex — элемент становится флекс-контейнером, ведёт себя как блочный, а вложенные элементы становятся флекс-элементами. ",
            "grid — элемент становится грид-контейнером. Снаружи грид-контейнер ведёт себя как блок. Дочерние элементы такого контейнера начинают подчиняться правилам грид-раскладки.",
            "Это свойство можно применить к любому HTML-элементу."
          ]
        }
      ]
    },
    {
      "id": "3",
      "title": "Булев тип",
      "subtitle": "На некоторые вопросы нужно отвечать только «да» или «нет». Булев тип как раз про это",
      "img": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/USeV/KgYaJXcaC",
      "views": 76,
      "userId": "1",
      "createdAt": "12.05.2024",
      "type": [
        "JavaScript"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Кратко",
          "paragraphs": [
            "Логический или булев тип boolean может принимать лишь истинное (true) и ложное (false) значения. Назван он так в честь Джорджа Буля, одного из основателей математической логики.",
            "Значения этого типа используются в условных выражениях."
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "Как пишется",
          "paragraphs": [
            "Создать булево значение можно несколькими способами.",
            "Первый — явно указать значение, используя ключевые слова true и false:"
          ]
        },
        {
          "id": "3",
          "type": "CODE",
          "code": "// «Истина»\nconst truthyValue = true\n\n// «Ложь»\nconst falsyValue = false\n"
        },
        {
          "id": "4",
          "type": "TEXT",
          "paragraphs": [
            "Второй способ — использовать метод Boolean:"
          ]
        },
        {
          "id": "5",
          "type": "CODE",
          "code": "// «Истина»\nconst truthyValue = Boolean(1)\n\n// «Ложь»\nconst falsyValue = Boolean('')\n"
        },
        {
          "id": "5",
          "type": "TEXT",
          "paragraphs": [
            "Как видите, даже значения других типов, например, числовые или строковые, приводятся к булеву типу.",
            "Третий способ — использовать выражения, значениями которых будут «истина» или «ложь» (мы ниже поговорим о таких выражениях подробнее).",
            "Следующие два выражения истинны, потому что 4 действительно меньше 5."
          ]
        },
        {
          "id": "6",
          "type": "CODE",
          "code": "const truthyValue = Boolean(4 < 5)\nconst anotherTruthy = 4 < 5\n\nconsole.log(truthyValue)\n// true\n\nconsole.log(anotherTruthy)\n// true\n"
        },
        {
          "id": "7",
          "type": "TEXT",
          "paragraphs": [
            "Следующие два — ложны, потому что 2 * 2 === 4:"
          ]
        },
        {
          "id": "8",
          "type": "CODE",
          "code": "const falsyValue = Boolean(2 * 2 === 5)\nconst anotherFalsy = 2 * 2 === 5\n\nconsole.log(falsyValue)\n// false\n\nconsole.log(anotherFalsy)\n// false\n"
        },
        {
          "id": "9",
          "type": "TEXT",
          "paragraphs": [
            "Булевы значения можно использовать в условных выражениях."
          ]
        },
        {
          "id": "10",
          "type": "CODE",
          "code": "const isCorrect = true\nif (isCorrect) {\n  // Выполнится эта ветка кода,\n  // потому что оператор if проверяет,\n  // истинно ли выражение в скобках,\n  // и, если да, то выполняет этот код\n} else {\n  // Эта ветка не выполнится\n}\n\nconst isWrong = false\nif (isWrong) {\n  // Теперь не выполнится эта ветка,\n  // потому что выражение в скобках ложно\n} else {\n  // А вот эта — выполнится\n}\n"
        },
        {
          "id": "11",
          "type": "TEXT",
          "title": "Как понять",
          "paragraphs": [
            "Логические значения можно воспринимать как ответ на закрытый вопрос — «Да или нет?»",
            "Это понимание позволяет придумывать более подходящие названия для булевых переменных.",
            "Плохое название для логического значения не помогает понять, на какой вопрос отвечает переменная. Например, waitResponse — не очень хорошее название.",
            "А вот переменная с именем shouldWaitForResponse отвечает на более чёткий вопрос «Должен ли процесс подождать ответа за запрос?». А переменная isWaitingForResponse — на вопрос «Ждёт ли процесс ответа прямо сейчас?»",
            "Обычно логическим переменным дают названия, начинающиеся с английских глаголов is, should, does, can и подобных."
          ]
        },
        {
          "id": "12",
          "type": "TEXT",
          "title": "Выражения",
          "paragraphs": [
            "Выше мы говорили о выражениях, которые можно привести к логическим значениям. В JavaScript такими выражениями часто пользуются, чтобы построить условия.",
            "Булевым выражением в JavaScript может быть что угодно.",
            "Хитрость в том, чтобы знать, какое выражение в какое значение в итоге будет преобразовано. Например, все эти выражения трансформируются в false:"
          ]
        },
        {
          "id": "13",
          "type": "CODE",
          "code": "const falsy1 = Boolean(),\n  falsy2 = Boolean(0),\n  falsy3 = Boolean(null),\n  falsy4 = Boolean(''),\n  falsy5 = Boolean(false)\n"
        },
        {
          "id": "14",
          "type": "TEXT",
          "paragraphs": [
            "А все эти — в true:"
          ]
        },
        {
          "id": "15",
          "type": "CODE",
          "code": "const truthy1 = Boolean(true),\n  truthy2 = Boolean('true'),\n  truthy3 = Boolean('false'),\n  truthy4 = Boolean('Су Лин'),\n  truthy5 = Boolean([]),\n  truthy6 = Boolean({})\n"
        },
        {
          "id": "16",
          "type": "TEXT",
          "paragraphs": [
            "Обратите внимание, что строка 'false' преобразуется в логическое true. Так происходит потому, что непустая строка в JavaScript считается truthy значением — то есть таким, которое приводится к true.",
            "То же и с пустыми массивом [] и объектом {}. Они считаются truthy значениями, поэтому приводятся к true.",
            "Обратите внимание на списки truthy и falsy значений в JavaScript."
          ]
        }
      ]
    },
    {
      "id": "22",
      "title": "Что такое Webpack?",
      "subtitle": "Рассказываем, как устроен самый известный бандлер и как настроить базовый проект",
      "img": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/oSM2/ZD7nY3pYK",
      "views": 71,
      "userId": "1",
      "createdAt": "28.12.2023",
      "type": [
        "Webpack"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Кратко",
          "paragraphs": [
            "Webpack — это самый популярный сборщик в мире JS. Его функции легко расширяются с помощью сторонних пакетов, так что Webpack можно заставить делать практически что угодно. А если готового плагина не нашлось, благодаря мощному API можно написать решение под свой уникальный случай."
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "Базовое использование",
          "paragraphs": [
            "На базовом уровне использовать Webpack довольно просто. Представим, что в нашем приложении есть файл application.js с функциями, необходимыми для работы:"
          ]
        },
        {
          "id": "3",
          "type": "CODE",
          "code": "function sayHello() {\n  console.log('Hello!')\n}\n\nfunction sayBye() {\n  console.log('Bye!')\n}\n\n// Экспортируем эти функции,\n// чтобы воспользоваться ими в другом месте:\nexport { sayHello, sayBye }\n"
        },
        {
          "id": "4",
          "type": "TEXT",
          "paragraphs": [
            "Теперь создадим файл index.js, который будет использоваться как входная точка, и вызовем в нем функции приложения:"
          ]
        },
        {
          "id": "5",
          "type": "CODE",
          "code": "import { sayHello, sayBye } from './application'\n\nsayHello()\nsayBye()\n"
        },
        {
          "id": "6",
          "type": "TEXT",
          "paragraphs": [
            "Настроим Webpack, чтобы он собирал единый файл с кодом приложения.",
            "Для начала следует добавить Webpack в список зависимостей приложения:"
          ]
        },
        {
          "id": "7",
          "type": "CODE",
          "code": "npm install --dev webpack webpack-cli\n"
        },
        {
          "id": "8",
          "type": "TEXT",
          "paragraphs": [
            "webpack — основная зависимость, в которой хранится весь код, нужный для работы бандлера.",
            "webpack-cli — обёртка для запуска Webpack из командной строки, Command Line Interface.",
            "Теперь достаточно создать простой конфигурационный файл webpack.config.js:"
          ]
        },
        {
          "id": "9",
          "type": "CODE",
          "code": "// path — встроенный в Node.js модуль\nconst path = require('path')\n\nmodule.exports = {\n  // Указываем путь до входной точки:\n  entry: './src/index.js',\n  // Описываем, куда следует поместить результат работы:\n  output: {\n    // Путь до директории (важно использовать path.resolve):\n    path: path.resolve(__dirname, 'dist'),\n    // Имя файла со сборкой:\n    filename: 'bundle.js'\n  }\n}\n"
        },
        {
          "id": "10",
          "type": "TEXT",
          "paragraphs": [
            "Почти готово, осталось только добавить скрипт для сборки в package.json и вызвать его:"
          ]
        },
        {
          "id": "11",
          "type": "CODE",
          "code": "{\n  \"scripts\": {\n    \"build\": \"webpack\"\n  }\n}\n"
        },
        {
          "id": "12",
          "type": "CODE",
          "code": "npm run build\n"
        },
        {
          "id": "13",
          "type": "TEXT",
          "paragraphs": [
            "После выполнения в директории dist окажется файл bundle.js, который уже можно подключать на страницу в браузере.",
            "В корне проекта нужно создать папку src, а в ней файл index.html и подключить в него файл со сборкой:"
          ]
        },
        {
          "id": "14",
          "type": "CODE",
          "code": "<!DOCTYPE html>\n<html>\n  <head>\n    ...\n  </head>\n  <body>\n    ...\n    <script src=\"./dist/bundle.js\"></script>\n  </body>\n</html>\n"
        },
        {
          "id": "15",
          "type": "TEXT",
          "paragraphs": [
            "Если открыть этот файл в браузере, то в консоли появится приветствие и прощание."
          ]
        },
        {
          "id": "16",
          "type": "IMAGE",
          "src": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/f4FR/Xydm244EH",
          "title": "Рисунок 1"
        },
        {
          "id": "17",
          "type": "TEXT",
          "title": "Отслеживание изменений в проекте",
          "paragraphs": [
            "Заново запускать сборку после внесения каждой правки не очень удобно. Во-первых, придётся каждый раз писать команду в терминале. Во-вторых, полная сборка больших проектов может занимать десятки минут, и тратить столько времени каждый раз просто расточительно.",
            "Для решения этой проблемы можно воспользоваться режимом инкрементальной сборки, когда Webpack отслеживает изменения файлов с исходным кодом и автоматически собирает те части, которые изменились.",
            "Добавим новую команду в package.json:"
          ]
        },
        {
          "id": "18",
          "type": "CODE",
          "code": "{\n  \"scripts\": {\n    \"build\": \"webpack\",\n    \"watch\": \"webpack --watch\"\n  }\n}\n"
        },
        {
          "id": "19",
          "type": "TEXT",
          "paragraphs": [
            "Теперь достаточно открыть файл index.html в браузере и обновлять страницу после сохранения файлов с исходным кодом.",
            "Для большего удобства можно воспользоваться пакетом webpack-dev-server."
          ]
        }
      ]
    },
    {
      "id": "4",
      "title": "Почти всё в JavaScript — объект",
      "subtitle": "Что бы мы ни использовали при написании JS кода, почти всё это объекты под капотом",
      "img": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/wXWu/8Pu2SkFdm",
      "views": 108,
      "userId": "1",
      "createdAt": "22.02.2024",
      "type": [
        "JavaScript"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Кратко",
          "paragraphs": [
            "В JavaScript объект является прародителем всех других сущностей. Все типы данных и структуры, кроме примитивных, являются потомками объекта. По этой причине абсолютно у всех наследников объекта имеется набор общих методов: toString(), valueOf() и другие."
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "Массивы и функции",
          "paragraphs": [
            "Объект — это сущность с набором свойств. Мы можем добавлять, менять и удалять эти свойства."
          ]
        },
        {
          "id": "3",
          "type": "CODE",
          "code": "const programmer = { name: 'John', level: 'Junior' }\n\nprogrammer.mainLanguage = 'JavaScript'\ndelete programmer.level\n\nconsole.dir(programmer)\n"
        },
        {
          "id": "4",
          "type": "IMAGE",
          "src": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/aWbp/TMne2x3t8",
          "title": "Рисунок 1"
        },
        {
          "id": "5",
          "type": "TEXT",
          "paragraphs": [
            "Если взглянуть на массив, то у него тоже есть набор свойств, но свой. Например, у массива есть длина, есть методы для работы с ним. Обращение к элементу массива по индексу, как можно заметить, это очень похоже на обращение к полю объекта с помощью квадратных скобок."
          ]
        },
        {
          "id": "6",
          "type": "CODE",
          "code": "const shows = ['Breakind Bad', 'The Office', 'Silicon Valley']\n\nshows.length // свойство массива\n\nshows[1] // получить элемент массива, аналогично как у объекта shows['1']\n"
        },
        {
          "id": "7",
          "type": "TEXT",
          "paragraphs": [
            "Аналогичная ситуация с функциями — у них тоже есть набор свойств, который можно увидеть, выведя информацию о ней в консоль."
          ]
        },
        {
          "id": "8",
          "type": "CODE",
          "code": "function sum(a, b) {\n  return a + b\n}\n\nsum.arguments // можно вызвать свойство функции\nsum.someField = 'value' // можно присвоить значение в поле\n\nconsole.dir(sum)\n"
        },
        {
          "id": "9",
          "type": "TEXT",
          "paragraphs": [
            "В выводе есть и свойство someField, которое мы присвоили, и набор встроенных свойств и методов."
          ]
        },
        {
          "id": "10",
          "type": "IMAGE",
          "src": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/CN7k/WYK8aLNwj",
          "title": "Рисунок 2"
        },
        {
          "id": "11",
          "type": "TEXT",
          "paragraphs": [
            "Такая структура массивов и функций очень похожа на структуру объектов. Но на самом деле это и есть объекты, и в этом можно легко убедиться.",
            "Давайте посмотрим на свойство __proto__ у функции sum(), описанной выше.",
            "Свойство __proto__ является устаревшим (deprecated), не используйте его в коде, особенно для того, чтобы самостоятельно устанавливать прототип."
          ]
        },
        {
          "id": "12",
          "type": "IMAGE",
          "src": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/oPHm/rLHPFD3Hc",
          "title": "Рисунок 3"
        },
        {
          "id": "13",
          "type": "TEXT",
          "paragraphs": [
            "Если посмотреть свойство прототипа, то можно заметить, что прототипом текущего прототипа является объект. Заглянув в этот прототип, можно увидеть такую картину:"
          ]
        },
        {
          "id": "14",
          "type": "IMAGE",
          "src": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/6HHx/vm9Wm4Hic",
          "title": "Рисунок 4"
        },
        {
          "id": "15",
          "type": "TEXT",
          "paragraphs": [
            "В этой цепочке следующего прототипа уже нет, а это значит, что мы дошли до самого конца цепочки, то есть нашли прародителя. Если подобным образом вывести в консоль любой массив, то спускаясь ниже по цепочке прототипов, в конце обязательно будет именно прототип объекта. Любая сущность в JavaScript наследуется от объекта."
          ]
        },
        {
          "id": "16",
          "type": "IMAGE",
          "src": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/8xw8/kNdbPTwRw",
          "title": "Рисунок 5"
        },
        {
          "id": "17",
          "type": "TEXT",
          "title": "Примитивы",
          "paragraphs": [
            "В JavaScript существуют примитивные типы данных, такие как строки, числа или булевы значения. При работе со строкой можно обнаружить, что у неё тоже есть свойства и методы, к которым можно обратиться."
          ]
        },
        {
          "id": "18",
          "type": "CODE",
          "code": "const show = 'Breaking Bad'\n\nconsole.log(show.length)\n// 12\nconsole.log(show.charAt(1))\n// 'r'\nconsole.log(show.toUpperCase())\n// 'BREAKING BAD'\n"
        },
        {
          "id": "19",
          "type": "TEXT",
          "paragraphs": [
            "Но строка является примитивным типом данных, откуда же у неё поведение как у объекта? Когда происходит обращение к какому-то свойству или методу у примитива, происходит автоматическая обёртка (autoboxing) в специальный конструктор для примитива, который является наследником объекта. Для строки это будет функция String(). У этого объекта есть свойства и методы, которые и вызываются."
          ]
        },
        {
          "id": "20",
          "type": "CODE",
          "code": "const pet = 'dog'\nconst pet2 = new String('dog') // будет создан объект\n\nconsole.log(pet === pet2)\n// false, потому что в pet2 находится объект\n\nconsole.dir(pet2)\n/* Выведет\n{\n  0: \"d\",\n  1: \"o\",\n  2: \"g\",\n  length: 3\n}\n*/\n"
        },
        {
          "id": "21",
          "type": "TEXT",
          "paragraphs": [
            "Для других типов данных есть аналогичные функции: Number() для чисел, Boolean() для булевых значений. Все эти функции так же являются наследниками объекта.",
            "Главное отличие между объектами (массивами, функциями) и примитивами в том, что примитивы неизменяемые. Попытка изменения или добавления свойств к примитиву ничего не сделает."
          ]
        },
        {
          "id": "22",
          "type": "CODE",
          "code": "const cat = 'Boris'\n\ncat.color = 'red' // свойство не добавится\ndelete color.length // также ничего не изменится\n\nconst cats = ['Boris', 'Vasya', 'Murzik']\ncats.length = 5 // теперь массив стал длинной в 5 элементов\ncats.someField = 'value' // добавилось поле\n\nconsole.dir(cats)\n/*\n{\n  0: \"Boris\",\n  1: \"Vasya\",\n  2: \"Murzik\",\n  someField: \"value\",\n  length: 5\n}\n*/\n"
        },
        {
          "id": "23",
          "type": "TEXT",
          "paragraphs": [
            "Но не стоит путать примитив и объект, созданный через конструктор для примитива:"
          ]
        },
        {
          "id": "24",
          "type": "CODE",
          "code": "const cat = new String('Boris')\ncat.color = 'black'\n// добавится, так как в cat лежит объект, а не строка\n"
        }
      ]
    },
    {
      "id": "5",
      "title": "Функция как тип данных",
      "subtitle": "С функцией можно работать, как с любым другим типом данных: сохранять в переменную, передавать, возвращать из функции",
      "img": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/yWSy/JPGT24sfV",
      "views": 84,
      "userId": "1",
      "createdAt": "07.11.2023",
      "type": [
        "JavaScript"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Кратко",
          "paragraphs": [
            "Функции — это объект первого класса. Это означает, что функцию можно использовать так же, как и другие типы данных: сохранять в переменную, передавать аргументом и возвращать из функции.",
            "Технически, функция — это объект JavaScript, у которого есть внутренний метод Call(), который добавляет возможность вызова функции."
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "Как понять",
          "paragraphs": [
            "Во многих языках функции — это специальные конструкции языка. Они не являются типом данных, и набор операций, которые с ними можно делать ограничен — их можно только объявлять и вызывать.",
            "В JavaScript функция — это тип данных, примерно такой же как объект или строка. Это означает, что с ним можно работать так же, как и с любым другим типом данных — сохранять в переменную, передавать в качестве аргумента функции, возвращать из функций.",
            "О функции удобно думать как об объекте, который поддерживает операцию вызова."
          ]
        },
        {
          "id": "3",
          "type": "TEXT",
          "title": "Хранение функции в переменной",
          "paragraphs": [
            "Функции можно объявлять различными способами. Объявление функции с помощью функционального выражения не что иное, как присваивание безымянной функции переменной:"
          ]
        },
        {
          "id": "4",
          "type": "CODE",
          "code": "const answer = function() {\n  console.log('42!')\n}\n\nanswer()\n// 42!\n"
        },
        {
          "id": "5",
          "type": "TEXT",
          "paragraphs": [
            "Можно сохранять в переменную и функцию, объявленную другим способом. При этом оба имени функции будут работать:"
          ]
        },
        {
          "id": "6",
          "type": "CODE",
          "code": "function answerNumber() {\n  console.log('42!')\n}\n\nconst answer = answerNumber\n\nanswerNumber()\n// 42!\nanswer()\n// 42!\n"
        },
        {
          "id": "7",
          "type": "TEXT",
          "paragraphs": [
            "Переменная хранит ссылку на функцию, поэтому мы можем создавать столько переменных, сколько нам нужно и все они будут именами функции:"
          ]
        },
        {
          "id": "8",
          "type": "CODE",
          "code": "const answer = function() {\n  console.log('42!')\n}\n\nconst answerNumber = answer\nconst fn = answer\n"
        },
        {
          "id": "9",
          "type": "TEXT",
          "title": "Передача функции в вызов другой функции",
          "paragraphs": [
            "Функция может передаваться в качестве аргумента при вызове другой функции.",
            "Например, функция, которая может выполнить произвольную операцию между двумя числами. Два числа хранятся внутри функции, а операция, которую нужно выполнить, передаётся при вызове:"
          ]
        },
        {
          "id": "10",
          "type": "CODE",
          "code": "function performOperation(operation) {\n  const a = 10\n  const b = 99\n  return operation(a, b)\n}\n\nconst sum = performOperation(function(one, two) { return one + two })\nconsole.log(sum)\n// 109\n\nconst result = performOperation(function(num1, num2) { return num1 ** (num1 / num2)})\nconsole.log(result)\n// 1.2618568830660204\n"
        },
        {
          "id": "11",
          "type": "TEXT",
          "paragraphs": [
            "Таким образом логика операции может определяться вне функции, что делает её гибкой.",
            "Функции, которые ожидают получить другую функцию в качестве параметра — стандартное явление в JavaScript. Даже встроенные методы, такие как forEach() и filter() используют этот подход.",
            "Функции, которые принимают другие функции или возвращают их как аргумент, называются функциями высшего порядка. Такие функции позволяют писать на JavaScript в функциональном стиле.",
            "Другой случай использования — колбэки в асинхронном коде. Иногда необходимо выполнить операцию после того, как закончится какое-то действие. Например, когда пользователь кликнет на кнопку. В этом случае используется метод addEventListener(), который принимает имя события, и колбэк, который нужно вызвать при его наступлении:"
          ]
        },
        {
          "id": "12",
          "type": "CODE",
          "code": "document.getElementsByTagName('button')[0].addEventListener('click', function() {\n  console.log('Пользователь кликнул!')\n})\n"
        },
        {
          "id": "13",
          "type": "TEXT",
          "title": "Возвращение функции как результат вызова Скопировать ссылку \"Возвращение функции как результат вызова\"",
          "paragraphs": [
            "Функцию можно вернуть как результат работы другой функции. Например, можно сохранить данные для математической операции, но не выполнять её сразу, а вернуть функцию, которая выполнит операцию над указанными числами:\n\n"
          ]
        },
        {
          "id": "14",
          "type": "CODE",
          "code": "function lazySum(a, b) {\n  return function() {\n    return a + b\n  }\n}\n"
        },
        {
          "id": "15",
          "type": "TEXT",
          "paragraphs": [
            "Здесь очень легко запутаться во вложенности. При вызове lazySum() мы передаём два аргумента. Эти аргументы не используются тут же — мы создаём новую функцию, которая складывает два числа и возвращаем её. После вызова lazySum() мы можем сохранить эту функцию в переменную и использовать её, когда нужно:"
          ]
        },
        {
          "id": "16",
          "type": "CODE",
          "code": "const performSum = lazySum(99, 1)\nconsole.log(performSum)\n// function lazySum()\n\nconsole.log(performSum())\n// 100\n"
        },
        {
          "id": "17",
          "type": "TEXT",
          "paragraphs": [
            "Обратите внимание, что значения параметров a и b остаются доступны внутри вложенной функции. Эта особенность связана с контекстом выполнения и лексическим окружением функции. Такой подход также активно используется при разработке на JavaScript."
          ]
        }
      ]
    },
    {
      "id": "6",
      "title": "<html>",
      "subtitle": "Содержит всю страницу внутри — и метаданные, и контент",
      "img": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/VBJa/3JnHcUksR",
      "views": 3,
      "userId": "1",
      "createdAt": "22.05.2024",
      "type": [
        "HTML"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Кратко",
          "paragraphs": [
            "Элемент <html> открывает контейнер, в котором находится всё содержимое страницы. Это корневой, или родительский, элемент всего документа."
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "Пример",
          "paragraphs": []
        },
        {
          "id": "3",
          "type": "CODE",
          "code": "<!DOCTYPE html>\n<html>\n  <head>\n    ...\n  </head>\n  <body>\n    ...\n  </body>\n</html>\n"
        },
        {
          "id": "4",
          "type": "TEXT",
          "title": "Как пишется",
          "paragraphs": [
            "Тег <html> ставят сразу после <!DOCTYPE>."
          ]
        },
        {
          "id": "5",
          "type": "TEXT",
          "title": "Атрибуты",
          "paragraphs": [
            "manifest — указывает URI (унифицированный идентификатор ресурса) манифеста, который сообщает браузеру, какие элементы страницы могут быть закэшированы.",
            "title — добавляет всплывающую подсказку, которая появляется, когда курсор мыши задерживается в окне веб-страницы.",
            "version — определяет версию шаблона HTML-документа, но необходимости в этом нет (устарел в HTML4.01; вышел из употребления с версии HTML5).",
            "xmlns — необязательный для HTML5, но необходимый для XHTML-документов атрибут. Определяет пространство имён XML, в котором находится документ.",
            "prefix — здесь прописывают open-graph разметку, типа <html lang=\"ru-RU\" prefix=\"og: [http://ogp.me/ns#](http://ogp.me/ns#)\">. Это чтобы при репосте с сайта в VK, Facebook и другие соцсети передавались те заголовки, картинки и описания, которые мы укажем."
          ]
        },
        {
          "id": "6",
          "type": "TEXT",
          "title": "Подсказки",
          "paragraphs": [
            "В HTML есть атрибут lang, который подсказывает браузеру язык, на котором написан текст на странице. Если добавить lang в <html>, браузер правильно отобразит текст и подберёт подходящую для этого языка пунктуацию. Например, в английском тексте будут такие кавычки “ ”, а в русском такие «». Пишется так: lang=\"en\".",
            "Кроме того, атрибут lang позволяет браузеру понять, отличается ли язык страницы от языка вашей системы. Если да, то браузер предложит пользователю использовать онлайн-переводчик."
          ]
        },
        {
          "id": "7",
          "type": "CODE",
          "code": "<html lang=\"ru\">\n  ...\n</html>\n"
        }
      ]
    },
    {
      "id": "7",
      "title": "<head> всему голова",
      "subtitle": "Говорим о заголовке страницы, фавиконке, способах подключения стилей и скриптов",
      "img": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/z9fu/o75AKVXW9",
      "views": 29,
      "userId": "1",
      "createdAt": "16.03.2024",
      "type": [
        "HTML"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Кратко",
          "paragraphs": [
            "Элемент <head> содержит основную информацию о документе: метаданные (например, заголовок окна или кодировку), ссылки на скрипты и таблицы стилей.",
            "Эта информация не отображается на странице браузера. Пользователи увидят только заголовок окна страницы — его задаёт тег <title>, ну и фавиконку, если вы её поставите."
          ]
        },
        {
          "id": "2",
          "type": "IMAGE",
          "src": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/bcCS/Hsh3LH1QB",
          "title": "Рисунок 1"
        },
        {
          "id": "3",
          "type": "TEXT",
          "title": "Пример",
          "paragraphs": []
        },
        {
          "id": "4",
          "type": "CODE",
          "code": "<html>\n  <head>\n    <title>Заголовок страницы</title>\n  </head>\n</html>\n"
        },
        {
          "id": "5",
          "type": "TEXT",
          "title": "Как пишется",
          "paragraphs": [
            "Кроме <title>, внутри контейнера <head> можно разместить и другие элементы: <base>, <link>, <meta>, <script>, <style>. Вот пример того, как можно поставить фавиконку — маленькую иконку в углу вкладки браузера."
          ]
        },
        {
          "id": "6",
          "type": "CODE",
          "code": "<head>\n  <link rel=\"shortcut icon\" type=\"image/png\" href=\"/favicon.png\">\n</head>\n"
        }
      ]
    },
    {
      "id": "8",
      "title": "Объект Math",
      "subtitle": "Встроенный модуль с математическими функциями",
      "img": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/4YnD/mW8mXdihB",
      "views": 203,
      "userId": "1",
      "createdAt": "18.12.2023",
      "type": [
        "JavaScript"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Кратко ",
          "paragraphs": [
            "JavaScript — это язык, программы на котором можно выполнять в разных средах. В нашем случае речь идёт о браузерах и о серверной платформе Node.js. Если до сих пор вы не написали ни строчки кода на JS и читаете этот текст в браузере, на настольном компьютере, это значит, что вы буквально в считанных секундах от своей первой JavaScript-программы.\"\n"
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "Как пишется",
          "paragraphs": [
            "Для использования констант из объекта Math достаточно просто их указать. Таких констант куча, поэтому при необходимости их нужно поискать в документации:\n\n"
          ]
        },
        {
          "id": "3",
          "type": "CODE",
          "code": "console.log(Math.PI)\n// 3.141592653589793\n"
        },
        {
          "id": "4",
          "type": "TEXT",
          "paragraphs": [
            "Для вызова функций из объекта Math также достаточно просто их указать:"
          ]
        },
        {
          "id": "5",
          "type": "CODE",
          "code": "console.log(Math.abs(-118))\n// 118\n"
        },
        {
          "id": "6",
          "type": "TEXT",
          "title": "Как понять",
          "paragraphs": [
            "Объект Math можно считать сборником полезных функций и значений. Чаще всего используются функции для получения случайного числа, отрисовки элементов в случайном порядке или генерации фоновой картинки."
          ]
        }
      ]
    },
    {
      "id": "9",
      "title": "DOM - дом?",
      "subtitle": "На чём стоят три слона, на которых держится веб?",
      "img": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/b5bk/1pevJFBRE",
      "views": 46,
      "userId": "1",
      "createdAt": "26.12.2023",
      "type": [
        "JavaScript"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Кратко",
          "paragraphs": [
            "DOM (Document Object Model) — это специальная древовидная структура, которая позволяет управлять HTML-разметкой из JavaScript-кода. Управление обычно состоит из добавления и удаления элементов, изменения их стилей и содержимого.",
            "Браузер создаёт DOM при загрузке страницы, складывает его в переменную document и сообщает, что DOM создан, с помощью события DOMContentLoaded. С переменной document начинается любая работа с HTML-разметкой в JavaScript."
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "Как пишется",
          "paragraphs": [
            "Объект document содержит большое количество свойств и методов, которые позволяют работать с HTML. Чаще всего используются методы, позволяющие найти элементы страницы."
          ]
        },
        {
          "id": "3",
          "type": "TEXT",
          "title": "Свойства",
          "paragraphs": [
            "title — заголовок документа. Браузер обычно показывает его на вкладке.",
            "Установить свой заголовок можно простым присваиванием:"
          ]
        },
        {
          "id": "4",
          "type": "CODE",
          "code": "document.title = 'Моё название документа'\nconsole.log(document.title)\n// Моё название документа\n"
        },
        {
          "id": "5",
          "type": "TEXT",
          "paragraphs": [
            "forms — получить список форм на странице. Свойство только для чтения, напрямую перезаписать его нельзя.",
            "body — получить элемент <body> страницы.",
            "head — получить элемент <head> страницы."
          ]
        },
        {
          "id": "6",
          "type": "TEXT",
          "title": "Методы",
          "paragraphs": [
            "getElementById — поиск элемента по идентификатору;",
            "getElementsByClassName — поиск элементов по названию класса;",
            "getElementsByTagName — поиск элементов по названию тега;",
            "querySelector — поиск первого элемента, подходящего под CSS-селектор;",
            "querySelectorAll — поиск всех элементов подходящих под CSS-селектор."
          ]
        },
        {
          "id": "7",
          "type": "TEXT",
          "title": "Как понять",
          "paragraphs": [
            "Браузер создаёт DOM на основе HTML-кода страницы. Затем на основе DOM и других структур, браузер рисует страницу пользователю. При изменении DOM, браузер анализирует это и обновляет страницу.",
            "DOM и страница, которую видит пользователь, связаны. Если изменишь одно, то изменится и второе:",
            "пользователь заполняет форму — можно прочитать введённые значения в DOM;\nпри выборе страны, мы заполняем список городов в DOM — пользователь видит список.",
            "Высокоуровневая схема такого взаимодействия:"
          ]
        },
        {
          "id": "8",
          "type": "IMAGE",
          "src": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/YjHL/NkqHd4dXg",
          "title": "Рисунок 1"
        },
        {
          "id": "9",
          "type": "TEXT",
          "title": "Из чего состоит DOM",
          "paragraphs": [
            "HTML страница — это теги, вложенные друг в друга. Например:"
          ]
        },
        {
          "id": "10",
          "type": "CODE",
          "code": "<!DOCTYPE html>\n<head>\n  <title>Личный кабинет</title>\n</head>\n<body>\n  <header>\n    <ul class=\"menu\">\n      <li>Главная</li>\n      <li>Статьи</li>\n      <li>Контакты</li>\n    </ul>\n  </header>\n  <article id=\"12\">\n    <h1>Как выучить джаваскрипт?</h1>\n    <p>Нужно начать учиться.</p>\n  </article>\n</body>\n"
        },
        {
          "id": "11",
          "type": "TEXT",
          "paragraphs": [
            "Браузер превращает эту разметку в JavaScript представление, сохраняя при этом вложенность и свойства каждого HTML-элемента. Этого удаётся достичь с помощью специальной структуры данных — дерева.",
            "Каждый тег представляет собой узел дерева. У каждого узла могут быть дочерние узлы — таким образом сохраняется информация о вложенности тегов. Правда, слово тег в этом контексте не используют и говорят элемент. Например, HTML-код выше превратится в такое дерево:"
          ]
        },
        {
          "id": "12",
          "type": "IMAGE",
          "src": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/Qe81/xg5en7LQ6",
          "title": "Рисунок 2"
        },
        {
          "id": "13",
          "type": "TEXT",
          "paragraphs": [
            "Дерево состоит из обычных и текстовых узлов. Обычные узлы — это HTML-теги, а текстовые узлы — текст внутри тегов.",
            "Обычный узел называется Element, и он содержит в себе описание тега, атрибутов тега и обработчиков. Если изменить описание — изменится и HTML-код этого элемента (возможно что-то даже изменится на экране. Например, если поменять цвет шрифта). В статье Element мы разбираем всё необходимое для работы с элементами.",
            "У любого узла есть один родительский узел и дочерние. Родительский узел — элемент, в который вложен текущий узел, он может быть только один. Дочерние — узлы, которые вложены в текущий узел.",
            "Это правило не работает только в двух случаях:",
            "корневой узел — у такого узла нет родителя;",
            "текстовый узел — у таких узлов нет дочерних узлов, только родитель. Последний уровень любого DOM-дерева состоит из текстовых узлов."
          ]
        }
      ]
    },
    {
      "id": "10",
      "title": "Атрибут class",
      "subtitle": "Самый частый атрибут, который вы будете использовать. Задаёт класс элементу",
      "img": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/ao4N/i2JzjsmmS",
      "views": 38,
      "userId": "1",
      "createdAt": "16.04.2024",
      "type": [
        "HTML"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Кратко",
          "paragraphs": [
            "Универсальный атрибут тега, с помощью которого можно задать имя любому элементу на странице. Имя элемента в дальнейшем используется в качестве селектора в CSS и позволяет управлять стилями элемента. К тому же по имени класса удобно искать и манипулировать элементами на странице при помощи JavaScript."
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "Пример",
          "paragraphs": [
            "На странице может быть множество одинаковых тегов. Например, несколько заголовков второго уровня."
          ]
        },
        {
          "id": "3",
          "type": "CODE",
          "code": "...\n<!-- Первый заголовок -->\n<h2>В Санкт-Петербурге</h2>\n<p>Ветер, по Питерскому обыкновению, дул сразу со всех четырёх сторон.</p>\n<!-- Второй заголовок -->\n<h2>В России</h2>\n<p>«Умом Россию не понять...»</p>\n<!-- Третий заголовок -->\n<h2>В мире</h2>\n<p>На Брайтон Бич опять идут дожди.</p>\n...\n"
        },
        {
          "id": "4",
          "type": "TEXT",
          "title": "Как понять",
          "paragraphs": [
            "Имя класса может быть произвольным. Вы самостоятельно придумываете это название и задаёте его элементу при помощи атрибута class. Чтобы использовать имя класса в качестве селектора достаточно написать его в CSS, поставив перед именем точку. По точке браузер поймёт, что ему нужно искать не тег, а именно класс."
          ]
        },
        {
          "id": "5",
          "type": "TEXT",
          "title": "Как пишется",
          "paragraphs": [
            "Атрибут класса можно задать любому тегу в HTML-разметке. Как и любой другой атрибут, класс прописывается внутри треугольных скобок открывающего тега."
          ]
        },
        {
          "id": "6",
          "type": "CODE",
          "code": "<p class=\"text\">\n  Его экзистенциальная тоска выступает как побудительный мотив творчества,\n  однако символизм начинает импрессионизм.\n</p>\n"
        },
        {
          "id": "7",
          "type": "TEXT",
          "paragraphs": [
            "При выборе имени класса следует придерживаться нескольких правил:",
            "1. В именах классов используй только английские слова."
          ]
        },
        {
          "id": "8",
          "type": "CODE",
          "code": "<!-- Плохо -->\n<p class=\"osnovnoy-text\">\n  Его экзистенциальная тоска выступает как побудительный мотив творчества,\n  однако символизм начинает импрессионизм.\n</p>\n\n<!-- Хорошо -->\n<p class=\"main-text\">\n  Его экзистенциальная тоска выступает как побудительный мотив творчества,\n  однако символизм начинает импрессионизм.\n</p>\n"
        },
        {
          "id": "9",
          "type": "TEXT",
          "paragraphs": [
            "2. Имена классов пишутся маленькими буквами."
          ]
        },
        {
          "id": "10",
          "type": "CODE",
          "code": "<!-- Плохо -->\n<p class=\"Main-Text\">\n  Его экзистенциальная тоска выступает как побудительный мотив творчества,\n  однако символизм начинает импрессионизм.\n</p>\n\n<!-- Хорошо -->\n<p class=\"main-text\">\n  Его экзистенциальная тоска выступает как побудительный мотив творчества,\n  однако символизм начинает импрессионизм.\n</p>\n"
        },
        {
          "id": "11",
          "type": "TEXT",
          "paragraphs": [
            "3. Для разделения двух слов используются тире (-) или знак подчёркивания (_). Не используй camelCase"
          ]
        },
        {
          "id": "12",
          "type": "CODE",
          "code": "<!-- Плохо -->\n<p class=\"mainText\">\n  Его экзистенциальная тоска выступает как побудительный мотив творчества,\n  однако символизм начинает импрессионизм.\n</p>\n\n<!-- Хорошо -->\n<p class=\"main-text\">\n  Его экзистенциальная тоска выступает как побудительный мотив творчества,\n  однако символизм начинает импрессионизм.\n</p>\n\n<!-- Хорошо -->\n<p class=\"main__text\">\n  Его экзистенциальная тоска выступает как побудительный мотив творчества,\n  однако символизм начинает импрессионизм.\n</p>\n"
        },
        {
          "id": "13",
          "type": "TEXT",
          "paragraphs": [
            "4. Лучше не использовать больше трёх слов в имени класса."
          ]
        },
        {
          "id": "14",
          "type": "CODE",
          "code": "<!-- Плохо -->\n<p class=\"daily-news__main-alert-text\">\n  Его экзистенциальная тоска выступает как побудительный мотив творчества,\n  однако символизм начинает импрессионизм.\n</p>\n\n<!-- Хорошо -->\n<p class=\"news__main-text\">\n  Его экзистенциальная тоска выступает как побудительный мотив творчества,\n  однако символизм начинает импрессионизм.\n</p>\n"
        },
        {
          "id": "15",
          "type": "TEXT",
          "paragraphs": [
            "5. Не используй в названиях классов цифры или числительные. Завтра порядок блоков может измениться и нумерация будет сбивать с толку."
          ]
        },
        {
          "id": "16",
          "type": "CODE",
          "code": "<!-- Плохо -->\n<p class=\"text1\">\n  Его экзистенциальная тоска выступает как побудительный мотив творчества,\n  однако символизм начинает импрессионизм.\n</p>\n<p class=\"text-two\">Экзистенциализм сложен.</p>\n<p class=\"text3\">Художественное переживание последовательно.</p>\n\n<!-- Хорошо -->\n<p class=\"main-text\">\n  Его экзистенциальная тоска выступает как побудительный мотив творчества,\n  однако символизм начинает импрессионизм.\n</p>\n<p class=\"sub-text\">Экзистенциализм сложен.</p>\n<p class=\"note-text\">Художественное переживание последовательно.</p>\n"
        }
      ]
    },
    {
      "id": "11",
      "title": "Специфичность селекторов",
      "subtitle": "Как браузер решает, какие стили применять к элементу? Разбираемся, почему у селектора есть вес",
      "img": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/9KMm/bgE8QuiEJ",
      "views": 76,
      "userId": "1",
      "createdAt": "06.02.2024",
      "type": [
        "CSS"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Кратко",
          "paragraphs": [
            "Специфичность — это алгоритм, благодаря которому браузер определяет, какие именно стили из всего набора применить к элементу. В вычислениях участвуют CSS-селекторы. Если одному и тому же элементу подходит сразу несколько CSS-правил с разными селекторами, то браузер применяет те стили, вес селектора которых больше. Правило каскада «кто ниже, тот и выигрывает» при этом может нарушаться.",
            "Специфичность — это одно из базовых понятий в CSS."
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "Вес селекторов",
          "paragraphs": [
            "Давайте разберёмся, как браузер взвешивает селектор. Ниже перечислены типы селекторов по убыванию специфичности:",
            "1. Селекторы по идентификатору;",
            "2. Селекторы по классу, селекторы по атрибуту и селекторы с псевдоклассами;",
            "3. Селекторы по тегу, селекторы с псевдоэлементами.",
            "Комбинаторы +, >, ~, универсальный селектор * и псевдокласс :where() веса не имеют.",
            "Псевдоклассы :is(), :has() и :not() принимают вес наиболее специфичного селектора внутри скобок."
          ]
        },
        {
          "id": "3",
          "type": "TEXT",
          "title": "Система расчёта",
          "paragraphs": [
            "Существует удобный способ вычисления веса селектора в уме. Выше мы перечислили три группы сущностей, из которых может состоять селектор. Представим любой селектор в виде трёх нулей: 0.0.0.",
            "Селекторы по идентификатору увеличивают первую цифру.",
            "Селекторы по классу, по атрибуту или псевдокласс увеличивают вторую цифру.",
            "Селектор по тегу или псевдоэлемент увеличивают третью цифру.",
            "Один селектор равен единице. Пока сложно понять. Давайте разберёмся на примерах.",
            "Селектор #some состоит из одного идентификатора. Один селектор = 1. Увеличиваем первую цифру на 1. В итоге вес такого селектора равен 1.0.0.",
            ".class состоит из одного класса. Увеличиваем вторую цифру на 1. Получаем вес селектора 0.1.0.",
            "section состоит из одного тега. Увеличиваем последнюю цифру на 1. Вес селектора равен 0.0.1."
          ]
        },
        {
          "id": "4",
          "type": "TEXT",
          "title": "Атрибут style",
          "paragraphs": [
            "CSS-свойства, написанные в атрибуте style внутри HTML-разметки, перебивают свойства, написанные для этого элемента во внешних CSS-файлах или внутри тега <style>. Так что формально атрибут style самый специфичный, у него самый большой вес.",
            "Иногда его добавляют в формулу в виде четвёртой цифры, стоящей перед всеми. Посмотрим на примере:"
          ]
        },
        {
          "id": "5",
          "type": "CODE",
          "code": "<div class=\"element\" id=\"this\" style=\"color: purple; border: none\">\n  Some smart text\n</div>\n"
        },
        {
          "id": "6",
          "type": "CODE",
          "code": "div.element#this {\n  color: green;\n  border: 10px solid red;\n}\n"
        },
        {
          "id": "7",
          "type": "TEXT",
          "paragraphs": [
            "У селектора в CSS будет специфичность 1.1.1, потому что там указан один идентификатор, один класс и один селектор тега. Но в итоге текст в блоке будет пурпурным, а рамки не будет совсем. Потому что у атрибута style вес равен 1.0.0.0"
          ]
        },
        {
          "id": "8",
          "type": "TEXT",
          "title": "!important",
          "paragraphs": [
            "Ключевое слово !important нарушает все установленные спецификацией законы и насильно применяет свойство, после которого написано. Ему плевать на селектор CSS-правила, внутри которого это свойство написано. Будет так, и никак иначе.",
            "Формально это ключевое слово не имеет отношения к концепции специфичности. Но из-за его варварских замашек нельзя не принимать его во внимание.",
            "Тут к месту будет ещё раз напомнить, что ключевое слово !important всегда стоит использовать с осторожностью и не злоупотреблять им. В том числе из-за того, что оно нарушает естественную работу специфичности и каскада."
          ]
        }
      ]
    },
    {
      "id": "12",
      "title": ":has()",
      "subtitle": "Уникальный селектор, позволяющий стилизовать родителя при наличии конкретного ребёнка",
      "img": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/LmgD/VERhDqvRy",
      "views": 26,
      "userId": "1",
      "createdAt": "08.01.2024",
      "type": [
        "CSS"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Кратко",
          "paragraphs": [
            "Функция-псевдокласс :has()позволяет уточнить основной селектор дополнительным. Это единственный способ выбрать элемент на основе дочернего или соседнего элемента посредством CSS."
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "Пример",
          "paragraphs": [
            "Применяем стили ко всем ссылкам, которые содержат изображения:"
          ]
        },
        {
          "id": "3",
          "type": "CODE",
          "code": "a:has(img) {\n  /* Стили */\n}\n"
        },
        {
          "id": "4",
          "type": "TEXT",
          "paragraphs": [
            "Стили применятся только к такому <dt>, за которым сразу следует элемент <dd>:"
          ]
        },
        {
          "id": "5",
          "type": "CODE",
          "code": "dt:has(+ dd) {\n  /* Стили */\n}\n"
        },
        {
          "id": "6",
          "type": "TEXT",
          "title": "Как пишется",
          "paragraphs": [
            "selector1 — необязательный селектор (если не указан — правило применится ко всем подходящим элементам). Аргумент selector2 в :has() описывает селектор относительно своей точки отсчёта — selector1:"
          ]
        },
        {
          "id": "7",
          "type": "CODE",
          "code": "selector1:has(selector2) {\n  /* Стили */\n}\n"
        },
        {
          "id": "8",
          "type": "TEXT",
          "paragraphs": [
            "Если .class — валидный селектор, а #top — нет, то selector будет уточнён за счёт .class:"
          ]
        },
        {
          "id": "9",
          "type": "CODE",
          "code": "selector:has(.class, #top) {\n  /* Стили */\n}\n"
        },
        {
          "id": "10",
          "type": "TEXT",
          "title": "Как понять",
          "paragraphs": [
            "Функция-псевдокласс :has() принимает один или несколько селекторов любой сложности в качестве аргумента. В отличие от :is() и :where() правило применится только к тому селектору, который был описан до :has()"
          ]
        }
      ]
    },
    {
      "id": "13",
      "title": "Рекурсия",
      "subtitle": "Зачем функции вызывать саму себя — одна из любимых тем на собеседовании",
      "img": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/HKgb/CT68zD88f",
      "views": 219,
      "userId": "1",
      "createdAt": "04.11.2023",
      "type": [
        "JavaScript"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Кратко",
          "paragraphs": [
            "Рекурсия — это что-то, что описывает само себя.",
            "Представить рекурсию проще всего на примере зеркального коридора — когда напротив друг друга стоят два зеркала. Если посмотреть в одно, то в нём будет отражение второго, во втором — отражение первого и так далее."
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "Рекурсия в программировании",
          "paragraphs": [
            "В программировании под рекурсией чаще всего понимают функцию, которая вызывает саму себя.",
            "При решении некоторых задач мы можем обнаружить, что решение можно разбить на несколько простых действий и более простой вариант той же задачи.",
            "Например, при возведении числа в степень мы берём число, умножаем его на себя несколько раз. Эту операцию можно представить в виде:"
          ]
        },
        {
          "id": "3",
          "type": "CODE",
          "code": "// 2^5 = 2 * 2 * 2 * 2 * 2\n//\n// 1 шаг: 2\n// 2 шаг: 2 * 2\n// 3 шаг: 2 * 2 * 2\n// 4 шаг: 2 * 2 * 2 * 2\n// 5 шаг: 2 * 2 * 2 * 2 * 2\n//\n// Какой по счёту шаг —\n// столько и умножений.\n"
        },
        {
          "id": "4",
          "type": "TEXT",
          "paragraphs": [
            "Но это же можно представить в виде нескольких последовательных умножений на 2:"
          ]
        },
        {
          "id": "5",
          "type": "CODE",
          "code": "// 2^5 = ((((2 * 2) * 2) * 2) * 2)\n//\n// 1 шаг: 2\n// 2 шаг: 2 * 2  (результат 1-го шага * 2)\n// 3 шаг: 4 * 2  (результат 2-го шага * 2)\n// 4 шаг: 8 * 2  (результат 3-го шага * 2)\n// 5 шаг: 16 * 2  (результат 4-го шага * 2)\n//\n// Для получения нового результата\n// мы берём предыдущий и умножаем его на 2.\n"
        },
        {
          "id": "6",
          "type": "TEXT",
          "paragraphs": [
            "При таком представлении всё возведение в степень — это лишь умножение предыдущего результата на 2:"
          ]
        },
        {
          "id": "7",
          "type": "CODE",
          "code": "// 2^n = 2^(n-1) * 2\n// Значение степени двойки —\n// это предыдущее значение, умноженное на 2.\n"
        },
        {
          "id": "8",
          "type": "TEXT",
          "paragraphs": [
            "Именно такие задачи называются рекурсивными — когда часть условия ссылается на всю задачу в целом (или похожую на неё).",
            "У рекурсии 2 составляющие: повторяющиеся операции и базовый случай."
          ]
        },
        {
          "id": "9",
          "type": "TEXT",
          "title": "Повторяющиеся операции",
          "paragraphs": [
            "В примере с возведением в степень повторяющиеся операции — это умножение.",
            "Такие операции могут быть сложными и включать в себя несколько подзадач. Такое, например, часто встречается в математике.",
            "Знаменитая сумма всех натуральных чисел контринтуитивно равняется -1/12. А доказывается это именно рекурсивно."
          ]
        },
        {
          "id": "10",
          "type": "TEXT",
          "title": "Базовый случай",
          "paragraphs": [
            "Вторая важная часть рекурсии — это базовый случай.",
            "Базовый случай — это условие, при выполнении которого рекурсия заканчивается и функция больше не вызывает саму себя.",
            "Например, при возведении в степень базовый случай наступает, когда значение степени становится равно искомому."
          ]
        },
        {
          "id": "11",
          "type": "IMAGE",
          "src": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/4WiQ/49cUMEgjv",
          "title": "Рисунок 1"
        },
        {
          "id": "12",
          "type": "TEXT",
          "paragraphs": [
            "Как только выполнение доходит до базового случая, оно останавливается.",
            "Без базового случая любая рекурсивная функция уйдёт в бесконечное выполнение, потому что будет вызывать себя без конца.",
            "В JS это приводит к переполнению стека вызовов, и функция останавливается с ошибкой."
          ]
        },
        {
          "id": "13",
          "type": "IMAGE",
          "src": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/tK69/YqwxEU4ME",
          "title": "Рисунок 2"
        },
        {
          "id": "14",
          "type": "TEXT",
          "paragraphs": [
            "Если выполнить функцию без базового случая, которая лишь вызывает себя, получим ошибку."
          ]
        },
        {
          "id": "15",
          "type": "TEXT",
          "title": "Цикл и рекурсия",
          "paragraphs": [
            "Из-за повторяющихся операций рекурсия схожа с циклом. Их часто считают взаимозаменяемыми, но это всё же не совсем так.",
            "Рекурсия проигрывает циклу в следующем:",
            "Отлаживать рекурсию значительно сложнее, чем цикл, а если функция написана плохо — то и просто читать.\nОна может приводить к переполнению стека. Особенно это ощутимо в таких языках как JS, где переполнение стека может наступить раньше базового случая с высокой вероятностью.\nЕё выполнение может (хотя необязательно) занимать больше памяти.",
            "Цикл же проигрывает рекурсии в таких вещах:",
            "Его нельзя использовать в функциональном программировании, потому что он императивен.\nЦиклом гораздо сложнее обходить вложенные структуры данных, например, каталоги файлов.\nРезультат выполнения рекурсивной функции проще закэшировать, чтобы ускорить выполнение, с циклом это сделать сложнее.\nПри работе с общими ресурсами или асинхронными задачами чаще удобнее использовать рекурсивные функции из-за замыканий.",
            "Поэтому на вопрос «Что использовать: рекурсию или цикл?» ответом будет «Зависит от задачи», серебряной пули здесь нет :–)",
            "Давайте решим одну и ту же задачу с использованием цикла и рекурсии, чтобы увидеть разницу в подходах. Будем писать функцию для нахождения факториала.",
            "Факториал числа — это произведение всех чисел от единицы до этого числа. Например, факториал 5 — это произведение (1 × 2 × 3 × 4 × 5) = 120."
          ]
        },
        {
          "id": "16",
          "type": "TEXT",
          "title": "Факториал с помощью цикла",
          "paragraphs": [
            "Сперва решим задачу нахождения факториала с помощью цикла."
          ]
        },
        {
          "id": "17",
          "type": "CODE",
          "code": "function factorial(n) {\n  // Начальный результат будет равен 1,\n  // чтобы его можно было умножать на последующие числа.\n  // 0 подходит только для подсчёта суммы,\n  // потому что умножение на 0 всегда даёт 0.\n  let result = 1\n\n  for (let i = 0; i < n; i++) {\n    // Так как наш счётчик начинается с 0\n    // и растёт до n-1, нам нужно прибавить к нему\n    // единицу, чтобы правильно рассчитать произведение.\n    result *= i + 1\n  }\n\n  return result\n}\n\nconsole.log(factorial(5))\n// 120\n"
        },
        {
          "id": "18",
          "type": "TEXT",
          "paragraphs": [
            "В этой функции мы используем цикл, чтобы умножить каждое число на результат предыдущего умножения. То же самое мы можем сделать и рекурсивно."
          ]
        },
        {
          "id": "19",
          "type": "TEXT",
          "title": "Факториал с помощью рекурсии",
          "paragraphs": [
            "Для расчёта факториала рекурсивно мы создадим функцию, в которой в первую очередь опишем базовый случай, а уже потом — повторяющиеся действия.",
            "Хорошим правилом при работе с рекурсией считается первым делом описывать базовый случай (как ранний выход, early return) и только потом — всё остальное. Это позволяет сделать работу с рекурсией безопаснее."
          ]
        },
        {
          "id": "20",
          "type": "IMAGE",
          "src": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/3K93/odmw1uYXw",
          "title": "Рисунок 3"
        },
        {
          "id": "21",
          "type": "TEXT",
          "paragraphs": [
            "В виде блок-схемы мы можем представить алгоритм факториала как условие и под-вызов той же функции."
          ]
        },
        {
          "id": "22",
          "type": "CODE",
          "code": "function factorial(n) {\n  // Если мы пытаемся найти факториал 1,\n  // возвращаем 1 — это базовый случай.\n  if (n <= 1) {\n    return 1\n  }\n\n  // В остальных случаях\n  // возвращаем произведение n\n  // на факториал предыдущего числа —\n  // таким образом мы от n дойдём до 1,\n  // перебрав каждое число.\n  return n * factorial(n - 1)\n}\n\nconsole.log(factorial(5))\n// 120\n"
        },
        {
          "id": "23",
          "type": "TEXT",
          "paragraphs": [
            "Кроме того, что функция стала заметно короче, она теперь выражает непосредственно математическую суть факториала."
          ]
        },
        {
          "id": "24",
          "type": "IMAGE",
          "src": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/EFpq/sSgWKN1WP",
          "title": "Рисунок 4"
        },
        {
          "id": "25",
          "type": "TEXT",
          "paragraphs": [
            "Процесс вычисления факториала 5 будет состоять из 4 под-вызовов функции factorial().",
            "Разберём по шагам, что происходит с переменной n и результатом функции factorial после каждого вызова:"
          ]
        },
        {
          "id": "26",
          "type": "CODE",
          "code": "/*\n\nСперва мы «спускаемся вглубь» вызовов.\nПервый вызов создаёт новую область видимости:\nfactorial(5) {\n  в ней  переменная n становится равной 5;\n  n - 1 => 4; функция возвращает 5 * factorial(4);\n\n  Второй вызов создаёт ещё одну область видимости:\n  factorial(4) {\n    n => 4\n    n - 1 => 3\n    return 4 * factorial(3)\n\n    Третий вызов, ещё одна область видимости:\n    factorial(3) {\n      n => 3\n      n - 1 => 2\n      return 3 * factorial(2)\n\n      Четвёртый вызов, ещё одна область:\n      factorial(2) {\n        n => 2\n        n - 1 => 1\n        return 2 * factorial(1)\n\n        Финальный вызов, последняя область,\n        базовый случай:\n        factorial(1) {\n          n => 1\n          Так как это базовый случай, возвращаем 1.\n          После базового случая мы «поднимаемся наверх».\n        }\n\n        В этот момент результат factorial(1) становится равен 1\n        Возвращаем return 2 * 1\n      }\n\n      Результат factorial(2) => 2\n      return 3 * 2\n    }\n\n    factorial(3) => 6\n    return 4 * 6\n  }\n\n  factorial(4) => 24\n  return 5 * 24\n}\n\nПосле каждого return область видимости соответствующей функции очищается.\nРезультат вызова становится равным конкретному числу.\n\n*/\n"
        },
        {
          "id": "27",
          "type": "TEXT",
          "paragraphs": [
            "Минусы такой реализации:",
            "Много областей видимости (замыканий), которые относительно требовательны к памяти.\nОтносительно просто читать, но сложнее отлаживать, чем цикл.",
            "Плюсы:",
            "Если мы часто считаем факториалы, мы можем кэшировать результаты выполнения, чтобы не считать факториалы заново. Рекурсивная функция с кешем будет возвращать посчитанный ранее результат сразу же, цикл же будет считать заново.\nНевозможно повлиять на процесс подсчёта как-то извне, замыкания не дают внешнему миру получить доступ к переменным внутри."
          ]
        }
      ]
    },
    {
      "id": "14",
      "title": "Области видимости",
      "subtitle": "Не все переменные одинаково доступны — всё зависит от того, в каком месте кода их объявили",
      "img": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/2yy6/HbzPEpeFh",
      "views": 79,
      "userId": "1",
      "createdAt": "14.09.2023",
      "type": [
        "JavaScript"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Кратко ",
          "paragraphs": [
            "Мы используем переменные, чтобы хранить в них временные значения, а потом в нужный момент получать к ним доступ.",
            "Но не все переменные в нашем коде одинаково доступны. Доступна ли переменная и как получить к ней доступ, определяют области видимости.",
            "Область видимости — это часть программы, в которой мы можем обратиться к переменной, функции или объекту. Этой частью может быть функция, блок или вся программа в целом — то есть мы всегда находимся как минимум в одной области видимости.",
            "Области видимости можно представить как коробки, в которые мы кладём переменные. Переменные, которые лежат в одной коробке, могут общаться друг с другом."
          ]
        },
        {
          "id": "2",
          "type": "IMAGE",
          "src": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/UD3T/ERChTCb4q",
          "title": "Рисунок 1"
        },
        {
          "id": "3",
          "type": "TEXT",
          "paragraphs": [
            "Переменные также могут получить доступ к переменным из коробки, в которую вложена их коробка."
          ]
        },
        {
          "id": "4",
          "type": "IMAGE",
          "src": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/DVdF/g9U3NoBGP",
          "title": "Рисунок 2"
        },
        {
          "id": "5",
          "type": "TEXT",
          "paragraphs": [
            "Области видимости помогают скрывать переменные от нежелательного доступа, управлять побочными эффектами и разбивать код на смысловые блоки.",
            "Но прежде чем мы рассмотрим, как их использовать, разберёмся с тем, какие области видимости в JS вообще есть."
          ]
        },
        {
          "id": "6",
          "type": "TEXT",
          "title": "Глобальная область видимости",
          "paragraphs": [
            "Глобальная область видимости — это самая внешняя коробка из всех. Когда мы «просто объявляем переменную», вне функций, вне модулей, то эта переменная попадает в глобальную область видимости."
          ]
        },
        {
          "id": "7",
          "type": "CODE",
          "code": "const a = 42\n"
        },
        {
          "id": "8",
          "type": "TEXT",
          "paragraphs": [
            "Переменная в примере сейчас находится в глобальной области видимости. Это значит, что она будет доступна откуда угодно внутри модуля:"
          ]
        },
        {
          "id": "9",
          "type": "CODE",
          "code": "const a = 42\nconsole.log(a)\n// 42\n\nfunction wrap() {\n  const b = a\n  // Без проблем, переменная a доступна в этой функции\n}\n\nconst c = {\n  d: a,\n  // Хорошо, переменная a доступна и здесь\n}\n\nfunction secondWrap() {\n  const e = {\n    f: a,\n    // И тут ок, переменная a всё ещё доступна\n  }\n}\n"
        },
        {
          "id": "10",
          "type": "TEXT",
          "paragraphs": [
            "Переменные в глобальной области видимости называются глобальными переменными и доступны всем.",
            "Самый известный пример глобальной переменной — это console."
          ]
        },
        {
          "id": "11",
          "type": "CODE",
          "code": "console.log(console)\n// Console {debug: function, error: function,\n// log: function, info: function, warn: function, …}\n"
        },
        {
          "id": "12",
          "type": "TEXT",
          "paragraphs": [
            "JS в браузерах так устроен, что глобальные переменные попадают в объект window. Если очень грубо, то можно сказать, что window в случае браузера — это и есть глобальная область видимости."
          ]
        },
        {
          "id": "13",
          "type": "CODE",
          "code": "console.log(console)\n// Console {debug: function, error: function,\n// log: function, info: function, warn: function, …}\n\nconsole.log(window.console)\n// Console {debug: function, error: function,\n// log: function, info: function, warn: function, …}\n// То же самое, потому что это один и тот же объект\n"
        },
        {
          "id": "14",
          "type": "TEXT",
          "paragraphs": [
            "Глобальный объект window — это объект, который даёт доступ к Web API браузера. window рекурсивно «содержит сам себя», потому что все глобальные объекты находятся в window:"
          ]
        },
        {
          "id": "15",
          "type": "CODE",
          "code": "console.log(window)\n// Window {0: Window, ...}\n"
        },
        {
          "id": "16",
          "type": "TEXT",
          "paragraphs": [
            "Мы также можем определить глобальные переменные сами. Например, если в консоли браузера мы создадим какую-то переменную, а потом попробуем получить к ней доступ через window:"
          ]
        },
        {
          "id": "17",
          "type": "IMAGE",
          "src": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/MM8F/LxEE5pqpe",
          "title": "Рисунок 3"
        },
        {
          "id": "18",
          "type": "TEXT",
          "paragraphs": [
            "Это сработает только с var, но не с let или const. Почему, мы узнаем чуть позже."
          ]
        },
        {
          "id": "19",
          "type": "TEXT",
          "title": "Блочная область видимости",
          "paragraphs": [
            "Блочная область видимости ограничена программным блоком, обозначенным при помощи { и }. Простейший пример такой области — это выражение внутри скобок:"
          ]
        },
        {
          "id": "20",
          "type": "CODE",
          "code": "const a = 42\nconsole.log(a)\n// 42\n\nif (true) {\n  const b = 43\n  console.log(a)\n  // 42\n  console.log(b)\n  // 43\n}\n\nconsole.log(b)\n// ReferenceError: Can't find variable: b\n"
        },
        {
          "id": "21",
          "type": "TEXT",
          "paragraphs": [
            "Переменная b скрыта внутри области видимости блока внутри скобок и доступна только внутри этого блока, но не снаружи.",
            "Скобки могут, однако, не только отделять тело условия. Ими можно обрамлять и другие части кода. Это, например, бывает очень полезно в сложных switch-конструкциях. Например:\n\n"
          ]
        },
        {
          "id": "22",
          "type": "CODE",
          "code": "switch (animalType) {\n  case 'dog': {\n    const legs = 4\n    const species = 'mammal'\n    break\n  }\n\n  case 'fish': {\n    const legs = 0\n    const swims = true\n    break\n  }\n}\n"
        },
        {
          "id": "23",
          "type": "TEXT",
          "paragraphs": [
            "В примере выше в case нам надо выполнить несколько строчек. Удобно обернуть все операции в блок при помощи фигурных скобок — тогда все переменные и операции будут ограничены этим блоком, то есть блочной областью видимости."
          ]
        },
        {
          "id": "24",
          "type": "TEXT",
          "title": "Функциональная область видимости",
          "paragraphs": [
            "Функциональная область видимости — это область видимости в пределах тела функции. Можно сказать, что она ограничена { и } функции."
          ]
        },
        {
          "id": "25",
          "type": "CODE",
          "code": "const a = 42\n\nfunction scoped() {\n  const b = 43\n}\n\nconsole.log(a)\n// 42\nconsole.log(b)\n// Reference error\n"
        },
        {
          "id": "26",
          "type": "TEXT",
          "paragraphs": [
            "К переменной b есть доступ только внутри функции scoped.",
            "Функциональная область видимости — очень мощный инструмент для разделения кода. Во-первых, используя её, мы можем не опасаться за «пересечение имён» переменных.",
            "В одной области видимости объявить дважды let или const нельзя:"
          ]
        },
        {
          "id": "27",
          "type": "CODE",
          "code": "const a = 42\nconst a = 43\n// SyntaxError: Cannot declare a const variable twice: 'a'\n"
        },
        {
          "id": "28",
          "type": "TEXT",
          "paragraphs": [
            "Но функции создают собственные области видимости, которые не пересекаются, поэтому в этом случае ошибки не будет:"
          ]
        },
        {
          "id": "29",
          "type": "CODE",
          "code": "function scope1() {\n  const a = 42\n}\n\nfunction scope2() {\n  const a = 43\n}\n"
        },
        {
          "id": "30",
          "type": "TEXT",
          "paragraphs": [
            "Так как области видимости у функций не пересекаются и не связаны, первая функция не может обратиться к «внутренностям» соседней или вложенной функции, внутренности соседней функции скрыты в её области видимости и недоступны вне её:"
          ]
        },
        {
          "id": "31",
          "type": "CODE",
          "code": "function scope1() {\n  const a = 42\n}\n\nfunction scope2() {\n  console.log(a)\n  // Reference error\n}\n"
        },
        {
          "id": "32",
          "type": "TEXT",
          "paragraphs": [
            "То же и с дочерними областями:"
          ]
        },
        {
          "id": "33",
          "type": "CODE",
          "code": "function outer() {\n  function inner() {\n    const a = 42\n  }\n\n  console.log(a)\n  // Reference error\n}\n"
        },
        {
          "id": "34",
          "type": "TEXT",
          "paragraphs": [
            "Функциям доступны лишь переменные в её собственной области видимости (всё, что внутри её тела) и в родительских областях:"
          ]
        },
        {
          "id": "35",
          "type": "CODE",
          "code": "function outer() {\n  const a = 42\n\n  function inner() {\n    console.log(a)\n    // 42\n  }\n}\n"
        },
        {
          "id": "36",
          "type": "TEXT",
          "paragraphs": [
            "Здесь ошибки нет, потому что функции доступна своя область видимости, а также область видимости функции outer.",
            "Такое поведение, когда переменные родительских областей становятся доступны в дочерних, называется наследованием областей видимости.",
            "Заметим, что у функции inner никаких локальных переменных нет — она работает только с локальной переменной функции outer.",
            "Такой особенный доступ к локальным переменным родительской функции часто называют лексической областью видимости.",
            "Сокрытие «внутренностей» позволяет создавать независимые друг от друга блоки кода. Это, например, полезно, когда мы хотим запустить какой-то модуль в браузере с уверенностью, что он никак не повлияет на другой код."
          ]
        }
      ]
    },
    {
      "id": "15",
      "title": "box-sizing",
      "subtitle": "Это свойство определяет как будут вести себя размеры блока",
      "img": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/dXDu/h9CLxP5pL",
      "views": 65,
      "userId": "1",
      "createdAt": "01.09.2023",
      "type": [
        "CSS"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Кратко",
          "paragraphs": [
            "При помощи свойства box-sizing можно изменить то, как браузер будет рассчитывать размеры элемента.",
            "По умолчанию размером элемента считается размер контентной области. Если кроме width и height указать ещё и padding с border, то браузер посчитает размер элемента как width + padding * 2 + border * 2 и height + padding * 2 + border * 2.",
            "Если задать значение border-box для свойства box-sizing, то браузер изменит принцип расчёта и padding с border уже будут включены в width и height."
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "Пример",
          "paragraphs": [
            "Создадим два элемента и зададим обоим элементам идентичные стили:"
          ]
        },
        {
          "id": "3",
          "type": "CODE",
          "code": "<div class=\"element first\"></div>\n<div class=\"element second\"></div>\n"
        },
        {
          "id": "4",
          "type": "CODE",
          "code": ".element {\n  display: inline-block;\n  width: 100px;\n  height: 100px;\n  padding: 25px;\n  border: 10px solid #ffffff;\n}\n"
        },
        {
          "id": "5",
          "type": "TEXT",
          "paragraphs": [
            "Отличаться они будут только фоном и значением свойства box-sizing."
          ]
        },
        {
          "id": "6",
          "type": "CODE",
          "code": ".first {\n  box-sizing: content-box;\n  background-color: #2E9AFF;\n}\n\n.second {\n  box-sizing: border-box;\n  background-color: #F498AD;\n}\n"
        },
        {
          "id": "5",
          "type": "TEXT",
          "paragraphs": [
            "В итоге элементы получились разного размера! Как так? Мы ведь указали одинаковые ширину, высоту и внутренние отступы, а так же рамку"
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "Как понять",
          "paragraphs": [
            "Причина в том, что при значении свойства box-sizing, равном content-box (значение по умолчанию) ширина элемента рассчитывается следующим образом:",
            "Ширина контентной области (100) + внутренний отступ слева и справа (25 + 25) + ширина правой и левой рамок (10 + 10). Итого: 170 пикселей.",
            "Аналогично с высотой.",
            "Выходит что первый элемент получил размеры 170 х 170.",
            "Размер второго элемента считается иначе. Из-за значения свойства box-sizing браузер воспринимает width и height как конечные размеры элемента. Получается что в 100 пикселей указанной ширины уже включены и внутренние боковые отступы и боковые рамки. Размеры второго элемента будут 100 х 100."
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "Как пишется",
          "paragraphs": [
            "В качестве значения для свойства box-sizing невозможно использовать что-то кроме ключевых слов. Значение может быть только одно.",
            "Доступные значения:",
            "content-box — значение по умолчанию. Финальная ширина = ширина + правый внутренний отступ + левый внутренний отступ + правая рамка + левая рамка",
            "border-box — значение width и height являются финальными размерами элемента. Финальная ширина = ширина"
          ]
        }
      ]
    }
  ],
  "comments": [
    {
      "userId": "1",
      "articleId": "1",
      "text": "Комментарий к этой статье :)",
      "id": "nwXaDBu"
    }
  ],
  "users": [
    {
      "id": "1",
      "username": "admin",
      "password": "123",
      "features": {
        "isArticleRatingEnabled": true,
        "isCounterEnabled": false,
        "isAppRedesigned": true
      },
      "roles": [
        "ADMIN"
      ],
      "avatar": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/mXU6/anWVrqVqc",
      "jsonSettings": {
        "theme": "app-light-theme",
        "isFirstVisit": false,
        "isArticlesPageWasOpened": true
      }
    },
    {
      "id": "2",
      "username": "user",
      "password": "123",
      "features": {
        "isArticleRatingEnabled": true,
        "isCounterEnabled": false,
        "isAppRedesigned": true
      },
      "roles": [
        "USER"
      ],
      "avatar": "https://www.pavilionweb.com/wp-content/uploads/2017/03/man.png",
      "jsonSettings": {
        "theme": "app-light-theme",
        "isFirstVisit": false,
        "isArticlesPageWasOpened": true
      }
    },
    {
      "id": "3",
      "username": "manager",
      "password": "123",
      "features": {
        "isArticleRatingEnabled": true,
        "isCounterEnabled": true
      },
      "roles": [
        "MANAGER"
      ],
      "avatar": "https://www.pavilionweb.com/wp-content/uploads/2017/03/man.png",
      "jsonSettings": {
        "theme": "app-gray-theme",
        "isFirstVisit": false
      }
    },
    {
      "id": "4",
      "username": "testUser",
      "password": "123",
      "features": {
        "isArticleRatingEnabled": true,
        "isCounterEnabled": true
      },
      "roles": [
        "MANAGER"
      ],
      "avatar": "https://www.pavilionweb.com/wp-content/uploads/2017/03/man.png"
    }
  ],
  "profile": [
    {
      "id": "1",
      "first": "Илья",
      "lastname": "Барышев",
      "age": 27,
      "currency": "RUB",
      "country": "Armenia",
      "city": "Naberezhnye Chelny",
      "username": "admin",
      "avatar": "https://thumb.cloud.mail.ru/weblink/thumb/xw1/mXU6/anWVrqVqc"
    },
    {
      "id": "2",
      "first": "Иван",
      "lastname": "Иванов",
      "age": 300,
      "currency": "RUB",
      "country": "Russia",
      "city": "Minsk",
      "username": "user",
      "avatar": "https://www.pavilionweb.com/wp-content/uploads/2017/03/man.png"
    },
    {
      "id": "4",
      "first": "Виктор",
      "lastname": "Табачков",
      "age": 67,
      "currency": "RUB",
      "country": "Kazakhstan",
      "city": "Minsk",
      "username": "userViktor",
      "avatar": "https://www.pavilionweb.com/wp-content/uploads/2017/03/man.png"
    }
  ],
  "notifications": [
    {
      "id": "1",
      "title": "Уведомление 1",
      "description": "Произошло какое-то событие",
      "userId": "1"
    },
    {
      "id": "2",
      "title": "Уведомление 2",
      "description": "Произошло какое-то событие",
      "userId": "1",
      "href": "http://localhost:3000/admin"
    },
    {
      "id": "3",
      "title": "Уведомление 3",
      "description": "Произошло какое-то событие",
      "userId": "1",
      "href": "http://localhost:3000/admin"
    },
    {
      "id": "4",
      "title": "Уведомление 4",
      "description": "Произошло какое-то событие",
      "userId": "1"
    },
    {
      "id": "5",
      "title": "Уведомление 1",
      "description": "Произошло какое-то событие",
      "userId": "2"
    }
  ],
  "article-rating": [
    {
      "id": "1",
      "userId": "1",
      "articleId": "1",
      "rate": 4,
      "feedback": "В целом понравилась"
    },
    {
      "userId": "2",
      "articleId": "5",
      "rate": 5,
      "id": "Ju6ZzPb"
    }
  ],
  "profile-rating": [
    {
      "userId": "2",
      "rate": 5,
      "id": 1
    }
  ]
}